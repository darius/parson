# Something like C but re-syntaxed.
# TODO I think I'll be able to use x:y for module-relative names

top:    '' module :end.

# Declarations

module
	: external_declaration*.

external_declaration
	: function_definition
	| decl
	.

function_definition
	: "to" id 
            ['(' [param_decl ** ',' :chain] ')' [':' type | :Void] :Signature]
            block  :To
        .

param_decl
        : id ++ ',' :hug ':' type  :spread_params
        .

decl
        : type_decl | var_decl
        .

type_decl
        : "typedef" id '=' type ';'              :TBD
        | "enum" (id | :None) '{'
              [enumerator ** ',' :hug] ','?
          '}'                                    :Enum
        | "struct" id '{' [param_decl* :hug] '}' :TBD
        | "union"  id '{' [param_decl* :hug] '}' :TBD
        .

enumerator
        : id ('=' elem_expr | :None) :hug
        .

var_decl
        : "let" [id++',' :hug] ':' type ('=' elem_expr | :None) ';'     :Let
        | "array" id ':' type '=' '{' [elem_expr ** ',' :hug] ','? '}' :Array_decl  # ugh?
        .


# Types

type
        : '^' type                                  :Pointer
        | '[' (expr | :None) ']' type               :Array
        | '(' [type :'' :hug] ** ',' :hug ')' type  :Signature
        | "void"                                    :Void
        | id                                        :Type_name
        .


# Statements

block
	: '{' (decl | statement)* :hug '}' :Block
	.

statement
	: block
	| "while" expr block                  :While
	| "do" block "while" expr ';'         :Do
	| "for" (expr | :None) ';' (expr | :None) ';' (expr | :None) block
                                              :For
	| "continue" ';'                      :Continue
	| "break" ';'                         :Break
	| "return" (expr | :None) ';'         :Return
	| "if" expr block ("else" "if" expr block)* ("else" block | :None)
                                              :hug :Ifs
	| "match" expr '{' [case* :hug] '}'   :Switch
	| (expr | :None) ';'                  :Exp
	.

case
	: "on" expr ++ ',' :hug block  :Case
	| "else"                block  :Default
        .


# Expressions

expr
	: assignment_expr (',' assignment_expr :Seq)*
	.

elem_expr = assignment_expr.   # "no comma" expression.

assignment_expr
	: unary_expr assignment_operator assignment_expr  :Assign
	| conditional_expr
	.

assignment_operator
	: '='   :None
	| '*='  :'*'
	| '/='  :'/'
	| '%='  :'%'
	| '+='  :'+'
	| '-='  :'-'
	| '<<=' :'<<'
	| '>>=' :'>>'
	| '&='  :'&'
	| '@='  :'@'
	| '|='  :'|'
	.

conditional_expr
	: "if" expr branch ("else" "if" expr branch)* "else" branch :Ifs_exp
        | logical_or_expr
	.

branch  : '{' expr '}'.

logical_or_expr
	: logical_and_expr ('||' logical_and_expr :Or)*
	.

logical_and_expr
	: expr3 ('&&' logical_and_expr :And)*
	.

expr3
        : expr4 ( '=='     :'==' expr4 :Binary_exp
                | '!='     :'!=' expr4 :Binary_exp
                | '<='     :'<=' expr4 :Binary_exp
                | '>='     :'>=' expr4 :Binary_exp
                | '<' !'=' :'<'  expr4 :Binary_exp
                | '>' !'=' :'>'  expr4 :Binary_exp
                )*
        .

expr4
        : expr5 ( '+' !/[+=]/ :'+' expr5 :Binary_exp
                | '-' !/[-=]/ :'-' expr5 :Binary_exp
                | '|' !/[|=]/ :'|' expr5 :Binary_exp
                | '@' !'='    :'@' expr5 :Binary_exp
                )*
        .

expr5
        : unary_expr ( '*'  !'='    :'*'  unary_expr :Binary_exp
                     | '/'  !'='    :'/'  unary_expr :Binary_exp
                     | '%'  !'='    :'%'  unary_expr :Binary_exp
                     | '&'  !/[&=]/ :'&'  unary_expr :Binary_exp
                     | '<<' !'='    :'<<' unary_expr :Binary_exp
                     | '>>' !'='    :'>>' unary_expr :Binary_exp
                     )*
        .

unary_expr
        : "as" '(' type ')' expr    :TBD
	| '++' unary_expr           :Pre_incr
	| '--' unary_expr           :Pre_decr
	| unary_operator unary_expr :Unary_exp
	| "sizeoftype" type         :Sizeof_type
        | "sizeof" unary_expr       :Sizeof
        | postfix_expr
	.

unary_operator
	: '&' !'&' :'&'
	| '+' !'+' :TBD
	| '-' !'-' :'-'
	| '~'      :'~'
	| '!'      :'!'
	.

postfix_expr
	: primary_expr
            ( '[' expr ']'                           :Index
	    | '(' [assignment_expr ** ',' :hug] ')'  :Call
	    | '.' id  :Dot
	    | '^'     :Deref
	    | '++'    :Post_incr
	    | '--'    :Post_decr
            )*
	.

primary_expr
	: id             :Variable
	| integer        :Literal    # TODO when we have hex, octal, etc., we need to preserve that distinction
	| string_literal :String
        | char_literal   :Char_literal
	| '(' expr ')'
	.

string_literal ~: /"([^"]*)"/ FNORD.   # TODO
char_literal   ~: /'([^']*)'/ FNORD.  # TODO

FNORD         ~:      whitespace*.
whitespace    ~:      /\s+/ | comment.
comment       ~:      /#.*/.
keyword       ~:      /array|as|break|continue|do|else|enum|for|if|let|match|on|return|sizeof|sizeoftype|struct|to|typedef|union|void|while/ /\b/.
digit         ~:      /(\d)/.

id:                   !keyword /([A-Za-z_][A-Za-z_0-9]*)/.
integer:              digit+ FNORD :join :int.    # TODO negative too; and unsigned, etc.
