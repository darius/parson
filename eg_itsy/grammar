# Something like C but re-syntaxed.
# TODO I think I'll be able to use x:y for module-relative names

top:    '' module :end.

# Declarations

module
	: external_declaration*.

external_declaration
	: function_definition
	| decl
	.

function_definition
	: "to" id 
            ['(' [param_decl**',' :chain] ')' [':' type | :Void] :Signature]
            block  :To
        .

param_decl
        : id++',' :hug ':' type  :spread_params
        .

decl
        : type_decl | var_decl
        .

type_decl
        : "typedef" id '=' type ';'              :TBD
        | "enum" (id | :None) '{'
              [enumerator**',' :hug] ','?
          '}'                                    :Enum
        | "struct" id '{' [param_decl* :hug] '}' :TBD
        | "union"  id '{' [param_decl* :hug] '}' :TBD
        .

enumerator
        : id ('=' elem_exp | :None) :hug
        .

var_decl
        : "let" [id++',' :hug] ':' type ( '=' '[' [elem_exp**',' :hug] ','? ']' ';' :Array_decl  # till we have array literals in exps
                                        | '=' elem_exp ';'  :Let
                                        |     :None    ';'  :Let
                                        )
        .


# Types

type
        : '^' type                                  :Pointer
        | '[' (exp | :None) ']' type                :Array
        | '(' [type :'' :hug]**',' :hug ')' type    :Signature
        | "void"                                    :Void
        | id                                        :Type_name
        .


# Statements

block
	: '{' (decl | statement)* :hug '}' :Block
	.

statement
	: block
	| "while" exp block                   :While
	| "do" block "while" exp ';'          :Do
	| "for" (exp | :None) ';' (exp | :None) ';' (exp | :None) block
                                              :For
	| "continue" ';'                      :Continue
	| "break" ';'                         :Break
	| "return" (exp | :None) ';'          :Return
	| "if" exp block ("else" "if" exp block)* ("else" block | :None)
                                              :hug :Ifs
	| "match" exp '{' [case* :hug] '}'    :Switch
	| (exp | :None) ';'                   :Exp
	.

case
	: "on" elem_exp++',' :hug block  :Case
	| "else"                  block  :Default
        .


# Expressions

exp
	: assignment_exp (',' assignment_exp :Seq)*
	.

elem_exp = assignment_exp.   # "no comma" expression.

assignment_exp
	: unary_exp assignment_operator assignment_exp  :Assign
	| conditional_exp
	.

assignment_operator
	: '='   :None
	| '*='  :'*'
	| '/='  :'/'
	| '%='  :'%'
	| '+='  :'+'
	| '-='  :'-'
	| '<<=' :'<<'
	| '>>=' :'>>'
	| '&='  :'&'
	| '@='  :'@'
	| '|='  :'|'
	.

conditional_exp
	: "if" exp branch ("else" "if" exp branch)* "else" branch :Ifs_exp
        | logical_or_exp
	.

branch  : '{' exp '}'.

logical_or_exp
	: logical_and_exp ('||' logical_and_exp :Or)*
	.

logical_and_exp
	: exp3 ('&&' logical_and_exp :And)*
	.

exp3
        : exp4 ( '=='     :'==' exp4 :Binary_exp
               | '!='     :'!=' exp4 :Binary_exp
               | '<='     :'<=' exp4 :Binary_exp
               | '>='     :'>=' exp4 :Binary_exp
               | '<' !'=' :'<'  exp4 :Binary_exp
               | '>' !'=' :'>'  exp4 :Binary_exp
               )*
        .

exp4
        : exp5 ( '+' !/[+=]/ :'+' exp5 :Binary_exp
               | '-' !/[-=]/ :'-' exp5 :Binary_exp
               | '|' !/[|=]/ :'|' exp5 :Binary_exp
               | '@' !'='    :'@' exp5 :Binary_exp
               )*
        .

exp5
        : unary_exp ( '*'  !'='    :'*'  unary_exp :Binary_exp
                    | '/'  !'='    :'/'  unary_exp :Binary_exp
                    | '%'  !'='    :'%'  unary_exp :Binary_exp
                    | '&'  !/[&=]/ :'&'  unary_exp :Binary_exp
                    | '<<' !'='    :'<<' unary_exp :Binary_exp
                    | '>>' !'='    :'>>' unary_exp :Binary_exp
                    )*
        .

unary_exp
	: '++' unary_exp           :Pre_incr
	| '--' unary_exp           :Pre_decr
	| unary_operator unary_exp :Unary_exp
	| "sizeoftype" type        :Sizeof_type
        | "sizeof" unary_exp       :Sizeof
        | postfix_exp
	.

unary_operator
	: '&' !'&' :'&'
	| '+' !'+' :TBD
	| '-' !'-' :'-'
	| '~'      :'~'
	| '!'      :'!'
	.

postfix_exp
	: primary_exp
            ( '[' exp ']'                     :Index
	    | '(' [elem_exp**',' :hug] ')'  :Call
	    | '.' id   :Dot
	    | '^'      :Deref
	    | '++'     :Post_incr
	    | '--'     :Post_decr
            | ':' type :Cast    # TODO is this a good syntax?
            )*
	.

primary_exp
	: id             :Variable
	| integer        :Literal    # TODO when we have hex, octal, etc., we need to preserve that distinction
	| string_literal :String
        | char_literal   :Char_literal
	| '(' exp ')'
	.

string_literal ~: /"([^"]*)"/ FNORD.   # TODO
char_literal   ~: /'([^']*)'/ FNORD.  # TODO

FNORD         ~:      whitespace*.
whitespace    ~:      /\s+/ | comment.
comment       ~:      /#.*/.
keyword       ~:      /break|continue|do|else|enum|for|if|let|match|on|return|sizeof|sizeoftype|struct|to|typedef|union|void|while/ /\b/.
digit         ~:      /(\d)/.

id:                   !keyword /([A-Za-z_][A-Za-z_0-9]*)/.
integer:              digit+ FNORD :join :int.    # TODO negative too; and unsigned, etc.
