# star_thompsonlike_lowlevel.py ported to C ported to itsy
# TODO explicit clarity on signed vs. unsigned

enum Constant {
    loud = 0,
    max_insns = 8192,
    accept = 0,
}

to error(plaint: char@) {
    fprintf(stderr, "%s\n", plaint);
    exit(1);
}

enum Opcode {
    op_accept, op_eat, op_fork, op_loop
}

let ninsns: int;
let accepts: uint8[max_insns];
let ops: uint8[max_insns];
let arg1: int[max_insns];
let arg2: int[max_insns];

array names: char@[4] = {   # TODO leave out the 4
    "win", "eat", "fork", "loop",
}

to dump1(pc: int) {
    printf("%c %2u: %-4s ", if accepts[pc] {'*'} else {' '}, pc, names[ops[pc]]);
    printf(if pc == accept {"\n"} else if ops[pc] == op_eat {"'%c' %d\n"} else {"%d %d\n"},
           arg1[pc], arg2[pc]);
}

let occupied: uint8[max_insns];

to after(ch: char, start: int, end: int, next_states: int@@) {
    while start != end {
        let r: int = arg1[start];
        let s: int = arg2[start];
        switch ops[start] {
            case op_eat {
                if r == ch && !occupied[s] {
                    next_states@++@ = s;
                    occupied[s] = 1;
                }
                return;
            }
            case op_fork {
                after(ch, r, end, next_states);
                start = s;
            }
            case op_loop {
                after(ch, r, start, next_states);
                start = s;
            }
            default {
                error("Can't happen");
            }
        }
    }
}

let states0: int[max_insns];
let states1: int[max_insns];

to run(start: int, input: char@): int {
    let cur_start: int@;  let cur_end: int@;
    let next_start: int@; let next_end: int@;

    if accepts[start] {
        return 1;
    }

    cur_start = states0,  cur_end = cur_start;
    next_start = states1, next_end = next_start;
    cur_end++@ = start;
    memset(occupied, 0, ninsns); # N.B. we could avoid this by always
                                 # finishing the next_start..next_end
                                 # loop below

    for ; input@; ++input {
        let state: int@;
        for state = cur_start; state < cur_end; ++state {
            after(input@, state@, accept, &next_end);
        }
        for state = next_start; state < next_end; ++state {
            if (accepts[state@]) {
                return 1;
            }
            occupied[state@] = 0;
        }
        {
            let t: int@ = cur_start;
            cur_start = next_start, cur_end = next_end;
            next_start = next_end = t;
        }
    }
    return 0;
}
